# If not running interactively, don't do anything
[ -z "$PS1" ] && return

if [ -n "$CURSOR_TRACE_ID" ]; then
    echo "IS CURSOR"
    # Source cursor-specific configuration
    if [ -f "$HOME/cmt/dotfiles/private/cursor_bashrc.sh" ]; then
        source "$HOME/cmt/dotfiles/private/cursor_bashrc.sh"
    fi
    return
fi

export VISUAL=vim
export EDITOR=$VISUAL

# Disable terminal flow control to allow Ctrl+S for custom bindings
stty -ixon

# don't put duplicate lines in the history. See bash(1) for more options
# ... or force ignoredups and ignorespace
HISTCONTROL=ignoredups:ignorespace

# append to the history file, don't overwrite it
shopt -s histappend

# for setting history length see HISTSIZE and HISTFILESIZE in bash(1)
HISTSIZE=1000
HISTFILESIZE=2000
# Session PID: outer (terminal) PID so prompt/history/script filename stay consistent across script subshells
SESSION_PID=${ORIGINAL_PID:-$$}
HISTFILE=~/.history/bash_history.$SESSION_PID.$(date +%Y-%m-%d)
mkdir -p ~/.history

# Start script for this terminal session (outer PID in filename). Nested manual `script` calls are allowed.
if [ -z "${ORIGINAL_PID-}" ] && command -v script >/dev/null 2>&1; then
    export ORIGINAL_PID=$$
    mkdir -p ~/.script
    exec script -q ~/.script/script.$ORIGINAL_PID.$(date +%Y-%m-%d)
fi

# Chain of bash PIDs for the prompt: one PID when we're the direct child of script (session); add PIDs only when user runs `bash`. When user runs `bash`, start a new script session for that subshell (new file per PID).
if [ -n "${ORIGINAL_PID-}" ]; then
    _ppid=$(ps -o ppid= -p $$ 2>/dev/null | tr -d ' ')
    _pcomm=$(ps -o comm= -p $_ppid 2>/dev/null)
    case "$_pcomm" in
        script)
            if [ -z "${BASH_PID_CHAIN-}" ]; then
                export BASH_PID_CHAIN=$ORIGINAL_PID
            fi
            ;;
        *bash*)
            export BASH_PID_CHAIN=${BASH_PID_CHAIN:-$ORIGINAL_PID}:$$
            if command -v script >/dev/null 2>&1; then
                mkdir -p ~/.script
                exec script -q ~/.script/script.$$.$(date +%Y-%m-%d)
            fi
            ;;
        *)
            export BASH_PID_CHAIN=${BASH_PID_CHAIN:-$ORIGINAL_PID}:$$
            ;;
    esac
    unset -v _ppid _pcomm
else
    export BASH_PID_CHAIN=$$
fi

# check the window size after each command and, if necessary,
# update the values of LINES and COLUMNS.
shopt -s checkwinsize

# make less more friendly for non-text input files, see lesspipe(1)
[ -x /usr/bin/lesspipe ] && eval "$(SHELL=/bin/sh lesspipe)"

# set variable identifying the chroot you work in (used in the prompt below)
if [ -z "$debian_chroot" ] && [ -r /etc/debian_chroot ]; then
    debian_chroot=$(cat /etc/debian_chroot)
fi

# set a fancy prompt (non-color, unless we know we "want" color)
case "$TERM" in
    xterm-color) color_prompt=yes;;
esac

if [ "$color_prompt" = yes ]; then
    PS1='${debian_chroot:+($debian_chroot)}\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ '
else
    PS1='${debian_chroot:+($debian_chroot)}\u@\h:\w\$ '
fi
unset color_prompt force_color_prompt

# If this is an xterm set the title to user@host:dir
case "$TERM" in
xterm*|rxvt*)
    PS1="\[\e]0;${debian_chroot:+($debian_chroot)}\u@\h: \w\a\]$PS1"
    ;;
*)
    ;;
esac

# enable color support of ls and also add handy aliases
if [ -x /usr/bin/dircolors ]; then
    test -r ~/.dircolors && eval "$(dircolors -b ~/.dircolors)" || eval "$(dircolors -b)"
    alias ls='ls --color=auto'
    alias grep='grep --color=auto'
    alias fgrep='fgrep --color=auto'
    alias egrep='egrep --color=auto'
fi

# Alias definitions.
if [ -f ~/.bash_aliases ]; then
    . ~/.bash_aliases
fi

# enable programmable completion features (you don't need to enable
# this, if it's already enabled in /etc/bash.bashrc and /etc/profile
# sources /etc/bash.bashrc).
if [ -f /etc/bash_completion ] && ! shopt -oq posix; then
    . /etc/bash_completion
fi

## Include home directory in CDPATH
CDPATH=.:~/
export CDPATH
export CDF_DEFAULT=''

# Modifing the prompt
source "$HOME/.bash_colors"

PROMPT_COMMAND=precmd

# Optimized git info - single call to git status instead of 3
get-git-info(){
    # Get git branch (fast operation)
    local branch=$(git symbolic-ref HEAD 2>/dev/null | sed "s/refs\/heads\///g")

    if [ -z "$branch" ]; then
        GIT_BRANCH=""
        GIT_HAS_COMMITS=""
        GIT_HAS_CHANGES=""
        return 0
    fi

    # Single call to git status (was called 3 times before)
    local status=$(git status --porcelain 2>/dev/null)

    # Parse status output once for both staged and unstaged changes
    local has_commits=""
    local has_changes=""

    if [ -n "$status" ]; then
        # Check for staged changes (first character is not space or ?)
        if echo "$status" | grep -q '^[^? ] '; then
            has_commits="1"
        fi

        # Check for untracked or unstaged changes
        if echo "$status" | grep -q '^?? \|^.[^ ] '; then
            has_changes="1"
        fi
    fi

    # Set global variables for use in precmd
    GIT_BRANCH="$branch"
    GIT_HAS_COMMITS="$has_commits"
    GIT_HAS_CHANGES="$has_changes"
}

cur-hist() {
    echo "$(history | tail -n 1 | awk '{print $1}')"
}

precmd(){
    # Write bash history
    # history -a only appends and doesn't create the file if it doesn't exist
    # So we ensure the file exists first, then append
    [ -f "$HISTFILE" ] && history -a || history -w

    # Single optimized call to get all git info
    get-git-info

    SPACE=""
    if [ -n "$GIT_BRANCH" ]; then
        # Check for staged changes (commits ready)
        if [ -n "$GIT_HAS_COMMITS" ]; then
            COMMITS="${bldcyn}×"
            SPACE=" "
        else
            COMMITS=""
        fi

        # Check for unstaged/untracked changes
        if [ -n "$GIT_HAS_CHANGES" ]; then
            CHANGES="${bldcyn}+"
            SPACE=" "
        else
            CHANGES=""
        fi

        PROMPT_GIT="${bldwht}(${bldgrn}$GIT_BRANCH$SPACE$CHANGES$COMMITS${bldwht})"

    else
        PROMPT_GIT=""
    fi

    if [[ $EUID -ne 0 ]]; then
        PROMPT_MAIN="${bldpur}(${txtblu}\u${bldpur}@${txtblu}\h${bldpur})${txtblu}\w${txtrst}"
    else
        PROMPT_MAIN="${bldpur}(${txtblu}\u${bldpur}@${txtblu}\h${bldpur})${txtblu}\w${txtrst}"
    fi

    if [[ $STY != "" ]]; then
        PROMPT_SCREEN="${bldpur}[${bldgrn}$(echo $STY | grep -o ^[0-9]*)${bldpur}]"
    else
        PROMPT_SCREEN="${bldpur}[${bldred}---${bldpur}]"
    fi

    PROMPT_PID="${bldpur}{${bldcyn}${BASH_PID_CHAIN}${bldpur}}"

    export PS1="${PROMPT_PID}${PROMPT_SCREEN}${PROMPT_MAIN}${PROMPT_GIT}${bldpur}\n$ ${txtrst}"
    export PS2="${bldwht}↪ ${txtrst}"

}

# Vi command line edit mode
set -o vi

export FZF_DEFAULT_OPTS="--bind ctrl-b:preview-page-up,ctrl-f:preview-page-down --layout=reverse --preview 'bat --style=numbers --color=always --line-range :500 {}'"


## OSX Stuff

if [ -f ~/.git-completion.bash ]; then
  . ~/.git-completion.bash
fi

if [ -f ~/.osx.bash ]; then
  . ~/.osx.bash
fi

## Work Stuff

if [ -f ~/.work.bash ]; then
    . ~/.work.bash
fi

# Created by `userpath` on 2025-07-21 19:43:30
export PATH="$PATH:/Users/jschneider/.local/bin"
export BASH_SILENCE_DEPRECATION_WARNING=1
